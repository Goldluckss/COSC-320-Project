searchState.loadedDescShard("c4_rust", 0, "C4 Compiler in Rust\nError types for the compiler\nIO errors (file operations)\nLexer errors (tokenization)\nParser errors (syntax)\nSource location information for error reporting\nType errors (semantics)\nVM runtime errors\nColumn number (1-based)\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCreate a lexer error\nLine number (1-based)\nCreate a new source location\nCreate a parser error\nCreate a simple lexer error without location information\nCreate a simple parser error without location information\nCreate a simple type error without location information\nFormat the location as “line:column”\nCreate a type error\nCreate a VM error\nThe lexer state for tokenizing source code\nRepresents the current token with its metadata\nGet the current column position\nGet the current token\nReturns the argument unchanged.\nReturns the argument unchanged.\nGet the current line content for error reporting\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nGet the current line number\nName for identifier tokens\nCreate a new lexer from source code string\nGet the next token from the source code\nType of the token\nValue for numeric tokens\nParser for C4 compiler\nReturns the argument unchanged.\nGet the code segment\nGet the data segment\nGet the main function symbol if it exists\nInitialize the parser\nCalls <code>U::from(self)</code>.\nCreate a new parser\nParse the C source code\nSymbol representation\nSymbol table for managing variables and functions\nAdd a symbol to the symbol table\nSymbol class (Fun, Glo, Loc, Num, etc.)\nGet the current scope level\nGet the current symbol being processed (last added)\nGet a mutable reference to the current symbol\nEnter a new scope level\nCheck if a symbol exists\nExit the current scope level\nReturns the argument unchanged.\nReturns the argument unchanged.\nGet a symbol by name\nGet a symbol by index\nGet a mutable reference to a symbol by index\nGet the main function\nGet a mutable reference to a symbol\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCheck if the symbol table is empty\nGet an iterator over all symbols\nIterate over all symbols with mutable access\nGet the number of symbols in the table\nName of the symbol\nCreate a new symbol table\nCreate a new symbol\nRestore the saved state\nSave the current state of the symbol\nSymbol type (INT, CHAR, PTR)\nValue or address\nVM operation codes\nToken types for the lexer and parser\nType system\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCheck if this is a pointer type\nGet the precedence level of an operator token\nGet the size of this type in bytes\nCreate a pointer to this type\nConvert opcode to string representation for debugging\nVirtual Machine for executing compiled C4 code\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCreate a new virtual machine\nRun the VM starting at the specified entry point")