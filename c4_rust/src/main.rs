use std::env;
use std::fs;
use std::process;

use c4_rust::error::CompilerError;
use c4_rust::parser::Parser;
use c4_rust::vm::VirtualMachine;

fn main() -> Result<(), CompilerError> {
    let args: Vec<String> = env::args().collect();
    
    let mut src_flag = false;
    let mut debug_flag = false;
    let mut filename = None;
    
    // Parse command line arguments
    let mut i = 1;
    while i < args.len() {
        if args[i] == "-s" {
            src_flag = true;
        } else if args[i] == "-d" {
            debug_flag = true;
        } else {
            filename = Some(&args[i]);
            break;
        }
        i += 1;
    }
    
    // Check if filename is provided
    if filename.is_none() {
        eprintln!("usage: c4_rust [-s] [-d] file ...");
        process::exit(1);
    }
    
    // Read the source file
    let source = match fs::read_to_string(filename.unwrap()) {
        Ok(content) => content,
        Err(err) => {
            eprintln!("could not open({}): {}", filename.unwrap(), err);
            process::exit(1);
        }
    };
    
    if src_flag {
        println!("Compiling source file: {}", filename.unwrap());
    }
    
    // Create parser and compile the code
    let mut parser = Parser::new(source, src_flag);
    
    match parser.init() {
        Ok(_) => {},
        Err(err) => {
            eprintln!("Parser initialization error: {}", err);
            process::exit(1);
        }
    }
    
    match parser.parse() {
        Ok(_) => {},
        Err(err) => {
            eprintln!("Compilation error: {}", err);
            process::exit(1);
        }
    }
    
    // Get the generated code
    let code = parser.get_code();
    
    // Check for main function
    let main_fn = parser.get_main_function();
    
    if main_fn.is_none() {
        eprintln!("main() not defined");
        process::exit(1);
    }
    
    if src_flag {
        println!("Compilation successful!");
        
        // Print the generated bytecode
        let opcodes = [
            "LEA", "IMM", "JMP", "JSR", "BZ", "BNZ", "ENT", "ADJ", "LEV", "LI", "LC", "SI", "SC", "PSH",
            "OR", "XOR", "AND", "EQ", "NE", "LT", "GT", "LE", "GE", "SHL", "SHR", "ADD", "SUB", "MUL", "DIV", "MOD",
            "OPEN", "READ", "CLOS", "PRTF", "MALC", "FREE", "MSET", "MCMP", "EXIT"
        ];
        
        println!("Generated code:");
        let mut pc = 0;
        while pc < code.len() {
            let op = code[pc] as usize;
            if op < opcodes.len() {
                print!("{:4}: {:4}", pc, opcodes[op]);
                
                // Print operands for instructions that have them
                if op <= 7 { // LEA, IMM, JMP, JSR, BZ, BNZ, ENT, ADJ
                    if pc + 1 < code.len() {
                        println!(" {}", code[pc + 1]);
                        pc += 2;
                    } else {
                        println!(" ???");
                        pc += 1;
                    }
                } else {
                    println!();
                    pc += 1;
                }
            } else {
                println!("{:4}: ???", pc);
                pc += 1;
            }
        }
        
        return Ok(());
    }
    
    // Run the code
    let mut vm = VirtualMachine::new(
        code.to_vec(),         // Code segment
        parser.get_data().to_vec(), // Data segment
        256 * 1024,            // Stack size (256KB)
        debug_flag             // Debug flag
    );
    
    // Prepare command line arguments for the program
    let program_args: Vec<String> = args.iter()
                                      .skip(i + 1)
                                      .map(|s| s.clone())
                                      .collect();
    
    // Run the program
    match vm.run(main_fn.unwrap(), &program_args) {
        Ok(exit_code) => {
            if debug_flag {
                println!("Program exited with code: {}", exit_code);
            }
            process::exit(exit_code as i32);
        },
        Err(err) => {
            eprintln!("Runtime error: {}", err);
            process::exit(1);
        }
    }
}